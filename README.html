<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>readme</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="README_files/libs/clipboard/clipboard.min.js"></script>
<script src="README_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="README_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="README_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="README_files/libs/quarto-html/popper.min.js"></script>
<script src="README_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="README_files/libs/quarto-html/anchor.min.js"></script>
<link href="README_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="README_files/libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="README_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="README_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="README_files/libs/bootstrap/bootstrap-d6a003b94517c951b2d65075d42fb01b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="bigquery-transportation-analytics-project" class="level1">
<h1>BigQuery Transportation Analytics Project</h1>
<section id="overview" class="level2">
<h2 class="anchored" data-anchor-id="overview">ğŸ“Œ Overview</h2>
<p>This project demonstrates SQL-based analytics using Google BigQuery public datasets. The analysis focuses on understanding patterns in NYC yellow taxi trips through warehouse-style SQL queries, including baseline metrics, segmentation, and trend analysis.</p>
<p>The goal is to replicate how a data analyst would explore a large, event-level dataset to establish baseline behavior, identify key drivers of volume and value, and flag notable deviations from normal activity.</p>
<hr>
</section>
<section id="tech-stack" class="level2">
<h2 class="anchored" data-anchor-id="tech-stack">ğŸ§° Tech Stack</h2>
<ul>
<li>ğŸ—„ï¸ SQL (Google BigQuery)</li>
<li>ğŸ”— GitHub for version control</li>
<li>ğŸ“„ Optional CSV exports for results</li>
</ul>
<hr>
</section>
<section id="dataset" class="level2">
<h2 class="anchored" data-anchor-id="dataset">ğŸ—ƒï¸ Dataset</h2>
<ul>
<li><strong>Source:</strong> <code>bigquery-public-data.new_york_taxi_trips</code></li>
<li><strong>Fact table:</strong> <code>tlc_yellow_trips_2018</code> (one row per taxi trip)</li>
<li><strong>Dimension table:</strong> <code>taxi_zone_geom</code> (lookup table for pickup location context)</li>
<li><strong>Grain:</strong> one row per taxi trip prior to aggregation</li>
<li><strong>Notes:</strong> This repository stores SQL queries and documentation only. No data is stored locally.</li>
</ul>
<hr>
</section>
<section id="business-questions" class="level2">
<h2 class="anchored" data-anchor-id="business-questions">â“ Business Questions</h2>
<ol type="1">
<li>ğŸ“ˆ How does taxi traffic change over time?</li>
<li>ğŸ“ Where does taxi traffic come from (by location and fare patterns)?</li>
<li>ğŸ’µ How does revenue per trip differ across segments?</li>
<li>ğŸš¨ Are there notable trends or anomalies in traffic?</li>
</ol>
<hr>
</section>
<section id="findings" class="level2">
<h2 class="anchored" data-anchor-id="findings">ğŸ“Š Findings</h2>
<section id="executive-summary" class="level3">
<h3 class="anchored" data-anchor-id="executive-summary">ğŸ” Executive Summary</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th>Question</th>
<th>Key Metric</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Traffic over time</td>
<td>Daily trip volume</td>
<td>Stable baseline with strong weekly seasonality</td>
</tr>
<tr class="even">
<td>Traffic by location</td>
<td>Share of pickups (Manhattan)</td>
<td><strong>90.6%</strong> of all trips</td>
</tr>
<tr class="odd">
<td>Traffic by fare</td>
<td>Trips under $25</td>
<td><strong>86.3%</strong> of total volume</td>
</tr>
<tr class="even">
<td>Value by location</td>
<td>Avg revenue per trip (Manhattan)</td>
<td><strong>$14.32</strong></td>
</tr>
<tr class="odd">
<td>High-value segment</td>
<td>Avg revenue per trip (EWR)</td>
<td><strong>$91.86</strong></td>
</tr>
<tr class="even">
<td>Anomalies</td>
<td>Sustained deviations</td>
<td>None observed (episodic deviations only)</td>
</tr>
</tbody>
</table>
</section>
<section id="traffic-over-time" class="level3">
<h3 class="anchored" data-anchor-id="traffic-over-time">1ï¸âƒ£ Traffic Over Time</h3>
<p>Daily taxi trip volume in 2018 is relatively stable, exhibiting strong weekly seasonality with predictable weekdayâ€“weekend fluctuations. Outside of short-term variation and isolated dips, there is no sustained upward or downward trend in overall traffic. The sharp decline observed at the end of the series reflects data coverage limits rather than a real change in demand.</p>
<hr>
</section>
<section id="traffic-composition-by-location-and-fare" class="level3">
<h3 class="anchored" data-anchor-id="traffic-composition-by-location-and-fare">2ï¸âƒ£ Traffic Composition by Location and Fare</h3>
<section id="traffic-by-pickup-location" class="level4">
<h4 class="anchored" data-anchor-id="traffic-by-pickup-location">ğŸ“ Traffic by Pickup Location</h4>
<p>Taxi trip volume is extremely concentrated geographically. Manhattan accounts for approximately <strong>90.6% of all pickups</strong>, while Queens and Brooklyn contribute <strong>6.4%</strong> and <strong>1.3%</strong> respectively. All other boroughs together represent less than <strong>0.2%</strong> of total trips. This indicates that overall taxi demand in 2018 is overwhelmingly driven by activity within Manhattan, with outer boroughs playing a comparatively minor role in total trip volume.</p>
</section>
<section id="traffic-by-fare-pattern" class="level4">
<h4 class="anchored" data-anchor-id="traffic-by-fare-pattern">ğŸ’² Traffic by Fare Pattern</h4>
<p>Fare distributions show that taxi traffic is primarily driven by low- to mid-priced trips. Approximately <strong>48.6%</strong> of trips fall within the <strong>$10â€“$25</strong> range, while an additional <strong>37.7%</strong> cost under <strong>$10</strong>. Trips exceeding <strong>$50</strong> account for only <strong>4.5%</strong> of total volume, indicating that system usage is dominated by frequent, short-distance rides rather than infrequent high-value fares.</p>
<p><em>Together, these findings suggest that overall taxi traffic in 2018 is driven by frequent, short-distance trips concentrated in Manhattan, rather than by high-value or geographically dispersed rides.</em></p>
<hr>
</section>
</section>
<section id="revenue-per-trip-by-location" class="level3">
<h3 class="anchored" data-anchor-id="revenue-per-trip-by-location">3ï¸âƒ£ Revenue per Trip by Location</h3>
<p>Average revenue per trip varies substantially by pickup borough. While Manhattan accounts for the vast majority of trip volume, it exhibits the lowest average revenue per trip at approximately <strong>$14.32</strong>, reflecting a high frequency of short-distance rides. In contrast, outer boroughs generate fewer trips but higher average revenue per ride. Trips originating near <strong>EWR (Newark Airport)</strong> show the highest average revenue per trip (approximately <strong>$91.86</strong>), despite representing a very small share of total volume.</p>
<p>These patterns indicate that overall trip volume and per-trip value are not aligned across locations. High-demand areas drive system usage through frequent, low-value trips, while lower-volume segments contribute disproportionately higher revenue per trip.</p>
<hr>
</section>
<section id="trends-and-anomalies" class="level3">
<h3 class="anchored" data-anchor-id="trends-and-anomalies">4ï¸âƒ£ Trends and Anomalies</h3>
<p>Daily trip volume shows expected short-term fluctuations around a stable baseline. Several isolated days exhibit significantly higher or lower traffic than average, consistent with holidays or short-term disruptions. Weekly aggregation smooths daily noise and confirms the absence of any sustained upward or downward trend across the year, suggesting normal operational variability rather than structural change in demand.</p>
<hr>
</section>
</section>
<section id="project-structure" class="level2">
<h2 class="anchored" data-anchor-id="project-structure">ğŸ—‚ï¸ Project Structure</h2>
<pre><code>ad-hocâ€“bigquery-transportation-analytics
â”œâ”€â”€ .gitignore
â”œâ”€â”€ README.md
â””â”€â”€ sql
â”œâ”€â”€ 00_sanity_checks.sql
â”œâ”€â”€ 01_daily_traffic_over_time.sql
â”œâ”€â”€ 01a_weekly_traffic_trend.sql
â”œâ”€â”€ 02a_trips_by_pickup_borough.sql
â”œâ”€â”€ 02b_fare_buckets.sql
â”œâ”€â”€ 03a_revenue_per_trip_by_borough.sql
â””â”€â”€ 04_anomalous_days.sql
*Note: No output files are committed; results are reproducible by running the SQL scripts.*</code></pre>
<p>SQL scripts are numbered to reflect the analytical workflow, from data validation and baseline analysis through segmentation, value comparison, and anomaly detection.</p>
<hr>
</section>
<section id="key-skills-demonstrated" class="level2">
<h2 class="anchored" data-anchor-id="key-skills-demonstrated">ğŸ§  Key Skills Demonstrated</h2>
<ul>
<li>Ad-hoc reporting</li>
<li>Time-series analysis</li>
<li>Fact-to-dimension joins</li>
<li>Segmentation and distribution analysis</li>
<li>Grain control and validation</li>
<li>Careful interpretation of trends and anomalies</li>
</ul>
<hr>
</section>
<section id="how-to-reproduce" class="level2">
<h2 class="anchored" data-anchor-id="how-to-reproduce">â–¶ï¸ How to Reproduce</h2>
<ol type="1">
<li>Open the Google BigQuery Console</li>
<li>Enable BigQuery Public Datasets</li>
<li>Run the SQL scripts in the <code>/sql</code> directory in numeric order</li>
</ol>
<hr>
</section>
<section id="assumptions-limitations" class="level2">
<h2 class="anchored" data-anchor-id="assumptions-limitations">âš ï¸ Assumptions &amp; Limitations</h2>
<ul>
<li>Analysis is descriptive, not causal</li>
<li>Public dataset limitations apply</li>
<li>Results reflect 2018 NYC yellow taxi trips only</li>
<li>No local data storage; all queries run in BigQuery</li>
</ul>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "î§‹";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>